#include<ncurses.h>
#include<iostream>
#include<stdlib.h>
#include<fstream>
#include<cmath>
#include<string.h>
#include<string>
#include<vector>
#include<map>
#include<stack>
#define row_len 200

WINDOW *create_win(int height, int width, int starty, int startx)
{    WINDOW *local_win;

    local_win = newwin(height, width, starty, startx);
    box(local_win, 0 , 0);        /* 0, 0 gives default characters 
                     * for the vertical and horizontal
                     * lines            */
    wrefresh(local_win);        /* Show that box         */

    return local_win;
}

using namespace std;

WINDOW *pad,*frpad,*menu,*find_replace_menu,*menu1; 
int mrow,mcol,mypadpos=0,mypadcol=0,PREVROW,PREVCOL,change_line;
string find_string,man_string,find_replace_string;
string replace_string;


class stack_obj{
   int Y,X,Z;
   string undo_string;
   public:
   stack_obj();
   stack_obj(int ,int,int ,string);
   string get_undo_string();
   void set_undo_string(string);
   int get_X();
   void set_X(int);
   int get_Y();
   void set_Y(int);
   int get_Z();
   void set_Z(int);   
};

//Constructor for the stack_obj class.
stack_obj::stack_obj(){
                 this->X = 0;
                 this->Y = 0;
                 this->Z = 0;
}


//parmeterized constructor for stack_obj class.
stack_obj::stack_obj(int X,int Y,int Z,string undo_string){
                 this->X = X;
                 this->Y = Y;
                 this->Z = Z;
                 this->undo_string = undo_string;
}

//function to get undo string.
string stack_obj::get_undo_string(){
        return this->undo_string;
}

//function to set undo string.
void stack_obj::set_undo_string(string undo_string){
      this->undo_string = undo_string; 
}

//function to return X Row.
int stack_obj::get_X(){
        return this->X;
}

//function to set X Row.
void stack_obj::set_X(int X){
        this->X = X;
}


//function to return Y column.
int stack_obj::get_Y(){
        return this->Y;
}

//function to set Y col.
void stack_obj::set_Y(int Y){
        this->Y = Y;
}

//function to return Z column.
int stack_obj::get_Z(){
        return this->Z;
}

//function to set Z Row.
void stack_obj::set_Z(int Z){
        this->Z = Z;
}


//class for node.
class node{
      node *next;                                                  
      node *prev;
      int start_word;
      int end_word;
      int row;
      string word;
      public:
      node();
      node(string,int,int);
      static node* create_node(string,int,int);
      void set_node(string,int,int);
      node* get_next_node();
      node* get_prev_node();
      void set_prev_node(node*);
      void set_next_node(node*);  
      void set_data(string);
      string get_data();
      static node* put_in_char_array(string,int,int);
      static void display();
      static void print_vector();
};

//The map for the keeping track of the rows.
vector<node*>mp;
int R=0,C=0;
stack<stack_obj>undo_stack;
stack<stack_obj>redo_stack;
vector<stack_obj>find_stack;
vector<stack_obj>replace_stack;
//constructor for node class.
node::node(){
     this->next = NULL;
     this->prev = NULL;
     this->start_word = 0;
     this->end_word = 0;
     this->row = 0;
}

//parameterized constructor.
node::node(string word,int start_word,int end_word){
        this->next = NULL;
        this->prev = NULL;
        this->start_word = start_word;
        this->end_word = end_word;
        this->word = word;      
}

//to set the node.
void node::set_node(string word,int start_word_index,int end_word_index){
     this->next = NULL;
     this->prev = NULL;
     this->start_word=start_word_index;
     this->end_word=end_word_index;
     this->word = word; 
}

//To set next Node.
void node::set_next_node(node *temp){
            this->next = temp;
}

//to set previous node.
void node::set_prev_node(node* temp){
          this->prev = temp;
}

//to get next node.
node* node::get_next_node(){
     return this->next;
}

//To Get previous node.
node* node::get_prev_node(){
     return this->prev;
} 

//To get word from node.
string node::get_data(){
         return this->word;
}

//To set the data of the node.
void node::set_data(string a){
           this->word = a;

}

//To create node.
node* node::create_node(string words,int start_of_word,int end_of_word){
         node* temp;
         temp = new node(words,start_of_word,end_of_word);
         return temp;
}

/*//To display text through the ncurses.
void node::display(){
         initscr();
         
         printw();
         refresh();
         endwin();
}*/



//class for linked list.
class ll{
     node *head;
     node *tail;
     public:
     ll();
     void set_head(node*);
     void set_tail(node*);
     node* get_tail();
     node* get_head();
     void adress_tracking(string);
     node* put_in_link_list(string,int,int);
     void print_link_list();
     void cursor_coordinate_arrow();
     void move_cursor_arrow();
     void Enter_key_pressed();
     void cursor_coordinate_enter();
     void manipulate_linklist_post_enter(); 
     node* inserting_node_post_enter(node*,int,int);
     void print();
     void Backspace_key_pressed();
     void manipulate_linklist_post_backspace();
     void manipulate_coordinates_post_backspace();                  
     void Delete_key_pressed();
     void manipulate_linklist_post_delete();
     void Write_into_text(char);
     void manipulate_linklist_postcharkey(char);
     void manipulate_coordinates_post_postcharkey();
     void del_node(node*);
     void append_data(node*);
     void undo();
     void set_coordinates_post_undo();
     void redo();
     void inserting_node_post_redo(node*,int,int,int);
     void inserting_node_post_undo(node*,int,int,int);
     void find_window();
     void find_string_in_text();
     void colour_text();
     void movement_find();
     void replace();
     void replace_word_in_text();
     void save_file(char*);
     void create_menu(char*);
     void find_window1();
     void find_window2();
     void replace_a_word_in_text();
};

//constructor for linked list class.
ll::ll(){
    this->head = NULL;
    this->tail = NULL;
}

//function to set head for the linklist.
void ll::set_head(node* head){
          this->head = head;
}

//function to set head for the linklist.
void ll::set_tail(node* tail){
          this->tail = tail;
}

//function to get the head of the linklist.
node* ll::get_head(){
      return this->head;
} 

//storing words into character array and keeping the address in a node.
node* ll::put_in_link_list(string prev_data,int start_of_word,int end_of_word){         
          int i,j;
          string words;
          //cout<<end_of_word;
          //words = new string[end_of_word-start_of_word+1];             
          for(j=0,i=start_of_word;i<end_of_word;i++,j++){
                  words += prev_data[i]; 
          }
          //words[j] = '\0';
          //for(i=0;words[i]!='\0';i++){
                  //cout<<words[i];
          //}
          //cout<<words;
          node *new_node = node::create_node(words,start_of_word,end_of_word);
          //cout<<new_node->get_data();
          if(this->head == NULL){
                   this->head = new_node;
          }
          else if(this->head!=NULL){
                 node* temp = this->head;
                 while(temp->get_next_node()!=NULL){
                      temp = temp->get_next_node();
                 }
                 temp->set_next_node(new_node);
                 new_node->set_prev_node(temp);
          }          
          return new_node;
}

//Inserting the node in the link list.
node* ll::inserting_node_post_enter(node *curr_node,int start_of_word,int end_of_word){
          int i,j;
          stack_obj obj;
          string words;
          words = curr_node->get_data();             
          /*for(j=0,i=start_of_word;i<end_of_word;i++,j++){
                  words += curr_node->get_data()[i]; 
          }*/
          words = words.substr(start_of_word,end_of_word);
          obj.set_X(R+1);
          obj.set_Y(C);
          obj.set_undo_string(words);
          obj.set_Z(2);
          undo_stack.push(obj);   
          node *new_node = node::create_node(words,0,words.length());
          if(this->head != NULL){
                  //temp->set_next_node(curr_n_node->get_next_node());
                  node *next_node = curr_node->get_next_node();
                  if(next_node!=NULL){
                  next_node->set_prev_node(new_node);
                  }
                  new_node->set_next_node(curr_node->get_next_node());
                  curr_node->set_next_node(new_node);
                  new_node->set_prev_node(curr_node);  
          }
          mp.insert(mp.begin()+(R+1),new_node);
          return new_node;
}

//Inserting the node in the link list.
void ll::inserting_node_post_undo(node *curr_node,int X,int start_of_word,int end_of_word){
          int i,j;
          string words;
          words = curr_node->get_data();             
          /*for(j=0,i=start_of_word;i<end_of_word;i++,j++){
                  words += curr_node->get_data()[i]; 
          }*/
          words = words.substr(start_of_word,end_of_word);   
          node *new_node = node::create_node(words,0,words.length());
          if(this->head != NULL){
                  //temp->set_next_node(curr_n_node->get_next_node());
                  node *next_node = curr_node->get_next_node();
                  if(next_node!=NULL){
                  next_node->set_prev_node(new_node);
                  }
                  new_node->set_next_node(curr_node->get_next_node());
                  curr_node->set_next_node(new_node);
                  new_node->set_prev_node(curr_node);  
          }
          mp.insert(mp.begin()+(X+1),new_node);
}


//Inserting the node in the link list.
void ll::inserting_node_post_redo(node *curr_node,int X,int start_of_word,int end_of_word){
          int i,j;
          stack_obj obj;
          string words;
          words = curr_node->get_data();             
          /*for(j=0,i=start_of_word;i<end_of_word;i++,j++){
                  words += curr_node->get_data()[i]; 
          }*/
          words = words.substr(start_of_word,end_of_word);
          /*obj.set_X(X);
          obj.set_Y(C);
          obj.set_undo_string(words);
          obj.set_Z(2);
          undo_stack.push(obj);*/   
          node *new_node = node::create_node(words,0,words.length());
          if(this->head != NULL){
                  //temp->set_next_node(curr_n_node->get_next_node());
                  node *next_node = curr_node->get_next_node();
                  if(next_node!=NULL){
                  next_node->set_prev_node(new_node);
                  }
                  new_node->set_next_node(curr_node->get_next_node());
                  curr_node->set_next_node(new_node);
                  new_node->set_prev_node(curr_node);  
          }
          mp.insert(mp.begin()+(X),new_node);
}


//funtion to track the words.
void ll::adress_tracking(string prev_data){
           int i=0,j=0,start=0,row=0,flag=0;
           while(prev_data[start]!='\0'&&prev_data[start+1]!='\0'){
                 i = start;
                 flag=0;
                 while(prev_data[start]!='\0'&&prev_data[start]!='\n'){
                      //if(prev_data[start]=='\n'){
                            //flag=1;
                            //row++;
                      //}
                   start++;
                   //cout<<start;
                 }
                 j = start+1;
                 node* temp =this->put_in_link_list(prev_data,i,j);
                 //if(strcmp(this->head->get_next_node()->get_data()," ")==0)
                 //cout<<this->head->get_next_node()->get_data()<<start;
                 if(row==0&&/*(this->head->get_next_node()==NULL||strcmp(this->head->get_next_node()->get_data()," ")==0)*/i==0){   
                         mp.push_back(this->head);
                         row++;
                   }
                 else if(row != 0&&prev_data[i-1]=='\n'&&prev_data[start]!='\0'){
                        //cout<<temp->get_data()<<endl;
                        mp.push_back(temp);
                        row++;
                 }
                 /*if(prev_data[start]!='\0'&&prev_data[start]=='\n'){
                     node* temp1 = this->put_in_char_array(prev_data,start,j+1);
                     //cout<<"hello"<<start<<endl;
                     if(this->head == NULL){
                            this->head = temp;
                     }
                     mp.push_back(temp1);
                     row++;
                 }*/
                 //if(prev_data[start]=='\n'){
                 //}
                 if(prev_data[start]!='\0')     
                     start += 1;           
           }
}


//Funtion To move the cursor.
void ll::cursor_coordinate_arrow(){
                noecho();
                getch();
                noecho();
          switch(getch()){
                  case 'A':
                       if(R>0&&C<mp[R-1]->get_data().length()) 
                                 R--;
                       else if(R>0&&C>mp[R-1]->get_data().length()-1){
                             if(mypadcol!=0){
                             mypadcol=mp[R-1]->get_data().length()-2;
                             }
                             C=mp[R-1]->get_data().length()-1;
                             R--;
                       }
                       if(R==mypadpos-1){
                          mypadpos--;
                      }
                       break;
                  case 'B':
                       if(R<mp.size()-1&&C<mp[R+1]->get_data().length()){ 
                              R++; 
                       }
                       else if(R<mp.size()-1&&C>mp[R+1]->get_data().length()){
                                   if(mypadcol!=0){
                                   mypadcol = mp[R+1]->get_data().length()-2;
                                   }
                                   C = mp[R+1]->get_data().length()-1;
                                   R++;
                       }
                       if(R-mypadpos==mrow){
                          mypadpos++;
                       }
                       break;
                  case 'C':
                       if(R<mp.size()-1&&(mp[R]->get_data()[C]=='\n')){
                             R++;
                             C=0;
                             mypadcol=0;
                             if(R-mypadpos==mrow){
                                   mypadpos++;
                       } 
                       }
                       else if(R<mp.size()&&(C<=mp[R]->get_data().length()-1)&&(mp[R]->get_data()[C]!='\n')){
                             C++;                            
                       }
                       //else if((R==mp.size()-1)&&(C<mp[R]->get_data().length())){             
                         //    C++;
                       //}
                       if(C-mypadcol==mcol)
                           mypadcol++;
                       break;  
                  case 'D':
                       if(C>0&&C==mypadcol) 
                           mypadcol--;
                       if(C>=0)
                           C--;
                       if(C<0&&R>=1){
                          R--;
                          C = mp[R]->get_data().length()-1;
                       }
                       break;        
         } 
               //delwin(pad);
               //pad = newpad(120,120);
               wclear(pad);
               wrefresh(pad);              
}

//Function to print the link list.
void ll::print_link_list(){
               node *temp = this->head;
               while(temp!=NULL){
                   int i=0;
                   while(temp->get_data()[i]) {
                        wprintw(pad,"%c",temp->get_data()[i]);
                        refresh();
                        i++;
                  }
               temp = temp->get_next_node();
               }
           wmove(pad,R,C);
           wrefresh(pad);
           prefresh(pad,mypadpos,mypadcol,0,0,mrow-1,mcol-1);            
}

//To move the cursor the all over the text.
void ll::move_cursor_arrow(){
               this->cursor_coordinate_arrow();
               node *temp = this->head;
               while(temp!=NULL){
                   int i=0;
                   while(temp->get_data()[i]) {
                        wprintw(pad,"%c",temp->get_data()[i]);
                        refresh();
                        i++;
                  }
               temp = temp->get_next_node();
               //wprintw(pad,"\t%d   %d",R,mypadpos);     
               }
           wmove(pad,R,C);
           wrefresh(pad);
       prefresh(pad,mypadpos,mypadcol,0,0,mrow-1,mcol-1);
}

//Function to manipulate Link List post Enter.
void ll::manipulate_linklist_post_enter(){
       int start=0,i=0;
       node* temp = this->inserting_node_post_enter(mp[R],C,mp[R]->get_data().length());
       //mp.push_back(temp);
       node *post_enter_node = mp[R];
       string mani_data =  post_enter_node->get_data();
       if(mani_data[C]!='\n')
       mani_data.insert(mani_data.begin()+C,'\n') ;
       //if(mani_data[C+1]!='\0')
       //mani_data.insert(mani_data.begin()+(C+1),'\0') ;
       mani_data.erase(mani_data.begin()+(C+1),mani_data.end());
       post_enter_node->set_data(mani_data);
}

//Function for manipulating the coordinates of the cursor post Enter.
void ll::cursor_coordinate_enter(){
         if(R-mypadpos==mrow-1){
                 mypadpos++;
         }
         mypadcol=0;
         R++;
         C=0;
         wclear(pad);
         wrefresh(pad);
}

//Function for implementing Functionality of Enter.
void ll::Enter_key_pressed(){  
        if(R<mp.size()&&C<mp[R]->get_data().length())
        this->manipulate_linklist_post_enter();
        int i;
        this->cursor_coordinate_enter();
        node *temp = this->head;
               while(temp!=NULL){                                                            
                    i=0;
                   while(temp->get_data()[i]) {
                       wprintw(pad,"%c",temp->get_data()[i]);
                        refresh();
                        i++;
                  }
               temp = temp->get_next_node();     
               }
        wmove(pad,R,C);
        wrefresh(pad);
        prefresh(pad,mypadpos,mypadcol,0,0,mrow-1,mcol-1);
        //printw("%d",mp.size());
}

//to manipulate the string after pressing the enter button.
void ll::manipulate_linklist_post_backspace(){
         node* temp = this->head;
         string temp_data;
         stack_obj obj;
         if(C<mp[R]->get_data().length()){
             //i=get_data().length();
             string man_data = mp[R]->get_data();
             /*while(i<man_data.length()){
                   man_data[i]=man_data[i+1];
                   i++;
             }*/
         temp_data = man_data;
         temp_data = temp_data.substr(C-1,1);
         obj.set_undo_string(temp_data);
         obj.set_X(R);
         obj.set_Y(C);
         obj.set_Z(1);
         undo_stack.push(obj);
         man_data.erase(man_data.begin()+C-1); 
         mp[R]->set_data(man_data);
         }
}

//To delete node if it is empty post backspace.
void ll::del_node(node* curr_node){
             int i=0;
            //node *head = this->head;
            /*while(strcmp(head->get_next_node()->get_data(),curr_node->get_data())!=0){
                              
            }*/
            node *prev_node = curr_node->get_prev_node();
            prev_node->set_next_node(curr_node->get_next_node());
            node *next_node=curr_node->get_next_node();
            if(next_node!=NULL)
            next_node->set_prev_node(prev_node);
            free(curr_node);
}  

//To append data after backspace is pressed.
void ll::append_data(node* curr_node){
             int i=0;
             node *prev_node = curr_node->get_prev_node();
             string man_data = curr_node->get_prev_node()->get_data();
             change_line = man_data.length();
             /*while(curr_node->get_prev_node()->get_data()[i]) {
                        printw("%c",curr_node->get_prev_node()->get_data()[i]);
                        refresh();
                        i++;
                  }*/
             man_data.erase(man_data.begin()+man_data.length()-1);
             man_data = man_data + curr_node->get_data();
             prev_node->set_data(man_data); 
} 

//To manipulate the coordinates of the cursor after pressing the backspace button.
void ll::manipulate_coordinates_post_backspace(){
           stack_obj obj;
           if(C==0&&R<mp.size()&&R>0&&(mp[R]->get_data()[C]=='\n'||mp[R]->get_data()[C]=='\0')){
                if(R==mypadpos)
                     mypadpos--;
                this->del_node(mp[R]);
                mp.erase(mp.begin()+R);
                C = mp[R-1]->get_data().length()-1;
                obj.set_X(R-1);
                obj.set_Y(C);
                obj.set_Z(4);
                undo_stack.push(obj);
                R--;
                //C = mp[R]->get_data().length()-1;
           }
           else if(C==0&&R<mp.size()&&R>0&&(mp[R]->get_data()[C]!='\n'||mp[R]->get_data()[C]!='\0')){
                if(R==mypadpos)
                     mypadpos--; 
                C = mp[R-1]->get_data().length()-1;
                this->append_data(mp[R]);
                this->del_node(mp[R]);
                mp.erase(mp.begin()+R);
                obj.set_X(R-1);
                obj.set_Y(change_line-1);
                obj.set_Z(4);
                undo_stack.push(obj);                 
                R--;                  
           }
           else if(C>0&&R<mp.size()){
                if(C==mypadcol){
                    mypadcol--;
                }
                C--;
           }
           else if(R>(mp.size()-1)&&R>0){
                R--;
                C = mp[R]->get_data().length()-1;
           }
           wclear(pad);
           wrefresh(pad);
}

//The backspace key pressed.
void ll::Backspace_key_pressed(){
            int i;
            if(/*R<mp.size()&&*/C>0)
            this->manipulate_linklist_post_backspace();
            this->manipulate_coordinates_post_backspace();     
            node *temp = this->head;
               while(temp!=NULL){                                                            
                    i=0;
                   while(temp->get_data()[i]) {
                        wprintw(pad,"%c",temp->get_data()[i]);
                        refresh();
                        i++;
                  }
               temp = temp->get_next_node();     
               }
               //printw("%d",mp.size());
               wmove(pad,R,C);
               wrefresh(pad);
               prefresh(pad,mypadpos,mypadcol,0,0,mrow-1,mcol-1);
}

//To manipulate the linklist after pressing delete button.
void ll::manipulate_linklist_post_delete(){
          int i=0;
          node* temp = this->head;
          if(C<mp[R]->get_data().length()){
             //i=get_data().length();
             i=C;
             string man_data = mp[R]->get_data();
             while(i<man_data.length()){
                   man_data[i]=man_data[i+1];
                   i++;
             }
         mp[R]->set_data(man_data);
         }   
}

//The Delete Key Pressed.
void ll::Delete_key_pressed(){
              int i;
              this->manipulate_linklist_post_delete();
              clear();
              refresh();
              node *temp = this->head;
               while(temp!=NULL){                                                            
                    i=0;
                   while(temp->get_data()[i]) {
                        wprintw(pad,"%c",temp->get_data()[i]);
                        refresh();
                        i++;
                  }
               temp = temp->get_next_node();     
               }
               wmove(pad,R,C);
               wrefresh(pad);
               prefresh(pad,mypadpos,0,0,0,mrow-1,mcol-1);
}



//To manipulate the string data after pressing a  char key.
void ll::manipulate_linklist_postcharkey(char a){
         int i,flag=0;
         //PR = R;
         stack_obj obj;
         string man_data,temp_data;       
         man_data = mp[R]->get_data();
         /*for(i=man_data.length()-1;i>C;i--){
                     man_data[i+1] = man_data[i];
         }*/
         man_data.insert(man_data.begin()+C,a);
         obj.set_X(R);
         //int len = man_data.length()-temp_string.length()-2;
         obj.set_Y(C);
         obj.set_Z(3);
         temp_data = a;
         obj.set_undo_string(temp_data);
         undo_stack.push(obj);
         mp[R]->set_data(man_data); 
}

void ll::manipulate_coordinates_post_postcharkey(){
            C++;
            if(C-mypadcol==mcol){
                   mypadcol++;
            }
            wclear(pad);
            wrefresh(pad);
}

//Funtion To write in the text.
void ll::Write_into_text(char a){
         int i;
         this->manipulate_linklist_postcharkey(a);
         this->manipulate_coordinates_post_postcharkey();
         node *temp = this->head;
               while(temp!=NULL){                                                            
                    i=0;
                   while(temp->get_data()[i]) {
                        wprintw(pad,"%c",temp->get_data()[i]);
                        refresh();
                        i++;
                  }
               temp = temp->get_next_node();     
               }
               wmove(pad,R,C);
               wrefresh(pad);
               prefresh(pad,mypadpos,mypadcol,0,0,mrow-1,mcol-1);
}

void ll::set_coordinates_post_undo(){
          C = undo_stack.top().get_Y()-1;
          R = undo_stack.top().get_X();
          wclear(pad);
          wrefresh(pad);
}

void ll::undo(){
     int i=0,flag=0;
     stack_obj curr_obj = undo_stack.top();
     stack_obj temp_obj,temp_obj1;
     int choice;
     choice = curr_obj.get_Z();
     switch(choice){
              case 1:
                    {
                    int row=curr_obj.get_X();
                    int ls = curr_obj.get_Y();
                    int len = curr_obj.get_Y();
                      node * curr_node = mp[curr_obj.get_X()];
                      string man_data = curr_node->get_data();
                      //if(man_data[man_data.length()-1]='\n'){
                          //man_data.erase(man_data.begin()+man_data.length()-1);
                      //}
                      string temp_data = curr_obj.get_undo_string();
                      while(temp_data[0]==' '&&undo_stack.empty()!=1&&row==curr_obj.get_X()&&len == ls&&curr_obj.get_Z()==1){
                      //curr_node = mp[curr_obj.get_X()];
                      //man_data = curr_node->get_data();
                      //temp_data = curr_obj.get_undo_string();
                        if(curr_obj.get_Z()!=1){
                            break;
                      }
                      man_data.insert(curr_obj.get_Y()-1,temp_data);
                      redo_stack.push(curr_obj);
                      undo_stack.pop();
                      if(undo_stack.empty()!=1){
                      curr_obj=undo_stack.top();
                      temp_data = curr_obj.get_undo_string();
                      ls++;
                      len = curr_obj.get_Y();
                      }
                      }
                      //temp_data = curr_obj.get_undo_string();
                       while(temp_data[0]!=' '&&undo_stack.empty()!=1&&row==curr_obj.get_X()&&ls == len&&curr_obj.get_Z()==1){
                      //curr_node = mp[curr_obj.get_X()];
                      //man_data = curr_node->get_data();
                      //temp_data = curr_obj.get_undo_string();
                        if(curr_obj.get_Z()!=1){
                            break;
                      }
                      man_data.insert(curr_obj.get_Y()-1,temp_data);
                      redo_stack.push(curr_obj);
                      undo_stack.pop();
                      if(undo_stack.empty()!=1){
                      curr_obj=undo_stack.top();
                      temp_data = curr_obj.get_undo_string();
                      ls++;
                      len = curr_obj.get_Y();
                      }
                      }
                      //man_data = man_data + '\n';
                      curr_node->set_data(man_data); 
                      R=curr_obj.get_X();
                      C= curr_obj.get_Y();
                    if(curr_obj.get_Y()-mypadcol==mcol||curr_obj.get_Y()-mypadcol>mcol){
                          mypadcol = C;
                      }
                   if(curr_obj.get_X()-mypadpos==mrow||curr_obj.get_X()-mypadpos>mrow){
                         mypadpos = R;
                      }
                   if(curr_obj.get_X()<mrow){
                            mypadpos = 0;
                   }
                   if(curr_obj.get_X()>mrow||curr_obj.get_X()==mrow){
                         mypadpos=(curr_obj.get_X()/mrow)*mrow;
                      }
                   if(curr_obj.get_Y()>mcol){
                         mypadcol=(curr_obj.get_Y()/mcol)*mcol;
                      }
                   if(curr_obj.get_Y()<mcol){
                            mypadcol = 0;
                   }
                      break;
                    }
             case 2:
                   {
                   node* curr_node = mp[curr_obj.get_X()];
                   node* next_node = mp[curr_obj.get_X()+1];
                   /*string man_data = curr_node->get_data();
                   string undo_data = curr_obj.get_undo_string();
                   man_data.erase(man_data.begin()+man_data.length()-1);
                   man_data = man_data+undo_data;
                   curr_node->set_data(man_data);
                   */
                   this->append_data(mp[curr_obj.get_X()]);
                   this->del_node(mp[curr_obj.get_X()]);
                   mp.erase(mp.begin()+curr_obj.get_X());
                   R = curr_obj.get_X()-1;
                   C = mp[curr_obj.get_X()-1]->get_data().length()-1;
                  if(curr_obj.get_Y()-mypadcol==mcol||curr_obj.get_Y()-mypadcol>mcol){
                          mypadcol = C;
                      }
                   if(curr_obj.get_X()-mypadpos==mrow||curr_obj.get_X()-mypadpos>mrow){
                         mypadpos = R;
                      }
                   if(curr_obj.get_X()<mrow){
                            mypadpos = 0;
                   }
                   if(curr_obj.get_X()>mrow||curr_obj.get_X()==mrow){
                         mypadpos=(curr_obj.get_X()/mrow)*mrow;
                      }
                   if(curr_obj.get_Y()>mcol){
                         mypadcol=(curr_obj.get_Y()/mcol)*mcol;
                      }
                   if(curr_obj.get_Y()<mcol){
                            mypadcol = 0;
                   }
                   redo_stack.push(curr_obj);
                   undo_stack.pop();                 
                   break;
                   }
             case 3:
                   { 
                   int row = curr_obj.get_X();
                   int ls = curr_obj.get_Y();
                   node*  curr_node = mp[curr_obj.get_X()];
                   string mani_string = curr_node->get_data();
                   int len = curr_obj.get_Y();
                   while(mani_string[len]==' '&&len>=0&&row == curr_obj.get_X()&&undo_stack.empty()!=1&&len==ls){
                         mani_string.erase(mani_string.begin()+len);
                         redo_stack.push(curr_obj);
                         undo_stack.pop();
                         if(undo_stack.empty()!=1){
                           curr_obj = undo_stack.top();
                           len = curr_obj.get_Y();
                           ls--;
                           }
                   }
                   while(mani_string[len]!=' '&&len>=0&&row == curr_obj.get_X()&&undo_stack.empty()!=1&&len==ls){
                         mani_string.erase(mani_string.begin()+len);
                         redo_stack.push(curr_obj);
                         undo_stack.pop();
                         if(undo_stack.empty()!=1){
                           curr_obj = undo_stack.top();
                           len = curr_obj.get_Y();
                           ls--;
                         }
                   }
                   curr_node->set_data(mani_string);
                   C = mani_string.length()-1;
                   R = curr_obj.get_X();
                   if(curr_obj.get_Y()-mypadcol==mcol||curr_obj.get_Y()-mypadcol>mcol){
                          mypadcol = C;
                      }
                   if(curr_obj.get_X()-mypadpos==mrow||curr_obj.get_X()-mypadpos>mrow){
                         mypadpos = R;
                      }
                   if(curr_obj.get_X()<mrow){
                            mypadpos = 0;
                   }
                   if(curr_obj.get_X()>mrow||curr_obj.get_X()==mrow){
                         mypadpos=(curr_obj.get_X()/mrow)*mrow;
                      }
                   if(curr_obj.get_Y()>mcol){
                         mypadcol=(curr_obj.get_Y()/mcol)*mcol;
                      }
                   if(curr_obj.get_Y()<mcol){
                            mypadcol = 0;
                   }                  
                   /*if(curr_obj.get_Y()==mcol-1){
                         mypadcol=0;
                   }*/
                   break;
                   }
               case 4:
                   {          
                        node *curr_node = mp[curr_obj.get_X()];
                        this->inserting_node_post_undo(curr_node,curr_obj.get_X(),curr_obj.get_Y(),curr_node->get_data().length());
                        node *post_enter_node = mp[curr_obj.get_X()];
                        string mani_data =  post_enter_node->get_data();
                        if(mani_data[curr_obj.get_Y()]!='\n')
                        mani_data.insert(mani_data.begin()+curr_obj.get_Y(),'\n') ;
                        //if(mani_data[C+1]!='\0')
                        //mani_data.insert(mani_data.begin()+(C+1),'\0') ;
                        mani_data.erase(mani_data.begin()+(curr_obj.get_Y()+1),mani_data.end());
                        post_enter_node->set_data(mani_data);
                        R = undo_stack.top().get_X()+1;
                        C = mp[undo_stack.top().get_X()+1]->get_data().length()-1;
                    if(curr_obj.get_Y()-mypadcol==mcol||curr_obj.get_Y()-mypadcol>mcol){
                          mypadcol = C;
                      }
                   if(curr_obj.get_X()-mypadpos==mrow||curr_obj.get_X()-mypadpos>mrow){
                         mypadpos = R;
                      }
                   if(curr_obj.get_X()<mrow){
                            mypadpos = 0;
                   }
                   if(curr_obj.get_X()>mrow||curr_obj.get_X()==mrow){
                         mypadpos=(curr_obj.get_X()/mrow)*mrow;
                      }
                   if(curr_obj.get_Y()>mcol){
                         mypadcol=(curr_obj.get_Y()/mcol)*mcol;
                      }
                   if(curr_obj.get_Y()<mcol){
                            mypadcol = 0;
                   }
                        redo_stack.push(curr_obj);
                        undo_stack.pop();
                        break; 
                   }
     }
     node *temp = this->head;
               while(temp!=NULL){                                                            
                    i=0;
                   while(temp->get_data()[i]) {
                        wprintw(pad,"%c",temp->get_data()[i]);
                        refresh();
                        i++;
                  }
               temp = temp->get_next_node();     
               }
               wmove(pad,R,C);
               wrefresh(pad);
               prefresh(pad,mypadpos,mypadcol,0,0,mrow-1,mcol-1);

}

void ll::redo(){
      stack_obj curr_obj = redo_stack.top();
      int choice;
      choice =  curr_obj.get_Z();
      switch(choice){
              case 1:
                    {
                       int row=curr_obj.get_X();
                      node * curr_node = mp[curr_obj.get_X()];
                      string man_data = curr_node->get_data();
                      //if(man_data[man_data.length()-1]='\n'){
                          //man_data.erase(man_data.begin()+man_data.length()-1);
                      //}
                      string temp_data = curr_obj.get_undo_string();
                      while(temp_data[0]==' '&&redo_stack.empty()!=1&&row==curr_obj.get_X()&&curr_obj.get_Z()==1){
                      //curr_node = mp[curr_obj.get_X()];
                      //man_data = curr_node->get_data();
                      //temp_data = curr_obj.get_undo_string();
                        if(curr_obj.get_Z()!=1){
                            break;
                      }
                      man_data.erase(man_data.begin()+curr_obj.get_Y()-1);
                      undo_stack.push(curr_obj);
                      redo_stack.pop();
                      if(redo_stack.empty()!=1){
                      curr_obj=redo_stack.top();
                      temp_data = curr_obj.get_undo_string();
                      }
                      }
                      //temp_data = curr_obj.get_undo_string();
                       while(temp_data[0]!=' '&&redo_stack.empty()!=1&&row==curr_obj.get_X()&&curr_obj.get_Z()==1){
                      //curr_node = mp[curr_obj.get_X()];
                      //man_data = curr_node->get_data();
                      //temp_data = curr_obj.get_undo_string();
                        if(curr_obj.get_Z()!=1){
                            break;
                      }
                      man_data.erase(man_data.begin()+curr_obj.get_Y()-1);
                      undo_stack.push(curr_obj);
                      redo_stack.pop();
                      if(redo_stack.empty()!=1){
                      curr_obj=redo_stack.top();
                      temp_data = curr_obj.get_undo_string();
                      }
                      }
                      //man_data = man_data + '\n';
                      curr_node->set_data(man_data); 
                      R=curr_obj.get_X();
                      C= curr_obj.get_Y()-2;
                    if(curr_obj.get_Y()-mypadcol==mcol||curr_obj.get_Y()-mypadcol>mcol){
                          mypadcol = C;
                      }
                   if(curr_obj.get_X()-mypadpos==mrow||curr_obj.get_X()-mypadpos>mrow){
                         mypadpos = R;
                      }
                   if(curr_obj.get_X()<mrow){
                            mypadpos = 0;
                   }
                   if(curr_obj.get_X()>mrow||curr_obj.get_X()==mrow){
                         mypadpos=(curr_obj.get_X()/mrow)*mrow;
                      }
                   if(curr_obj.get_Y()>mcol){
                         mypadcol=(curr_obj.get_Y()/mcol)*mcol;
                      }
                   if(curr_obj.get_Y()<mcol){
                            mypadcol = 0;
                   }
                      break; 
                    }
              case 2:
                    {
                     node* curr_node = mp[curr_obj.get_X()-1];
                     this->inserting_node_post_redo(curr_node,curr_obj.get_X(),curr_obj.get_Y(),curr_node->get_data().length());
                     node *post_redo_node = mp[curr_obj.get_X()-1];
                     string mani_data =  post_redo_node->get_data();
                     if(mani_data[curr_obj.get_Y()]!='\n')
                     mani_data.insert(mani_data.begin()+curr_obj.get_Y(),'\n') ;
                     //if(mani_data[C+1]!='\0')
                     //mani_data.insert(mani_data.begin()+(C+1),'\0') ;
                     mani_data.erase(mani_data.begin()+(curr_obj.get_Y()+1),mani_data.end());
                     post_redo_node->set_data(mani_data);
                     R = redo_stack.top().get_X();
                     C =mp[redo_stack.top().get_X()]->get_data().length()-1;
                    if(curr_obj.get_Y()-mypadcol==mcol||curr_obj.get_Y()-mypadcol>mcol){
                          mypadcol = C;
                      }
                   if(curr_obj.get_X()-mypadpos==mrow||curr_obj.get_X()-mypadpos>mrow){
                         mypadpos = R;
                      }
                   if(curr_obj.get_X()<mrow){
                            mypadpos = 0;
                   }
                   if(curr_obj.get_X()>mrow||curr_obj.get_X()==mrow){
                         mypadpos=(curr_obj.get_X()/mrow)*mrow;
                      }
                   if(curr_obj.get_Y()>mcol){
                         mypadcol=(curr_obj.get_Y()/mcol)*mcol;
                      }
                   if(curr_obj.get_Y()<mcol){
                            mypadcol = 0;
                   }
                     undo_stack.push(curr_obj);
                     redo_stack.pop();
                     break;
                    }
               case 3:
                    { 
                      int row=curr_obj.get_X();
                      node * curr_node = mp[curr_obj.get_X()];
                      string man_data = curr_node->get_data();
                      /*if(man_data[man_data.length()-1]='\n'){
                          man_data.erase(man_data.begin()+man_data.length()-1);
                      }*/
                      string temp_data = curr_obj.get_undo_string();
                      while(temp_data[0]==' '&&redo_stack.empty()!=1&&row==curr_obj.get_X()&&curr_obj.get_Z()==3){
                      //curr_node = mp[curr_obj.get_X()];
                      //man_data = curr_node->get_data();
                      //temp_data = curr_obj.get_undo_string();
                      man_data.insert(curr_obj.get_Y(),temp_data);
                      undo_stack.push(curr_obj);
                      redo_stack.pop();
                      if(redo_stack.empty()!=1){
                      curr_obj=redo_stack.top();
                      temp_data = curr_obj.get_undo_string();
                      }
                      }
                      //temp_data = curr_obj.get_undo_string();
                      while(temp_data[0]!=' '&&redo_stack.empty()!=1&&row==curr_obj.get_X()&&curr_obj.get_Z()==3){
                      //curr_node = mp[curr_obj.get_X()];
                      //man_data = curr_node->get_data();
                      man_data.insert(curr_obj.get_Y(),temp_data);
                      undo_stack.push(curr_obj);
                      redo_stack.pop();
                      if(redo_stack.empty()!=1){
                      curr_obj=redo_stack.top();
                      temp_data = curr_obj.get_undo_string();
                      }
                      }
                      //man_data = man_data + '\n';
                      curr_node->set_data(man_data); 
                      R=curr_obj.get_X();
                      C= mp[curr_obj.get_X()]->get_data().length()-1;
                    if(curr_obj.get_Y()-mypadcol==mcol||curr_obj.get_Y()-mypadcol>mcol){
                          mypadcol = C;
                      }
                   if(curr_obj.get_X()-mypadpos==mrow||curr_obj.get_X()-mypadpos>mrow){
                         mypadpos = R;
                      }
                   if(curr_obj.get_X()<mrow){
                            mypadpos = 0;
                   }
                   if(curr_obj.get_X()>mrow||curr_obj.get_X()==mrow){
                         mypadpos=(curr_obj.get_X()/mrow)*mrow;
                      }
                   if(curr_obj.get_Y()>mcol){
                         mypadcol=(curr_obj.get_Y()/mcol)*mcol;
                      }
                   if(curr_obj.get_Y()<mcol){
                            mypadcol = 0;
                   }
                      break;
                    }
               case 4:
                     { 
                           this->append_data(mp[curr_obj.get_X()+1]);
                           this->del_node(mp[curr_obj.get_X()+1]);
                           mp.erase(mp.begin()+curr_obj.get_X()+1);
                           undo_stack.push(curr_obj);
                           //if(redo_stack.empty()!=1)
                           redo_stack.pop();
                           R = curr_obj.get_X();
                           C = mp[curr_obj.get_X()]->get_data().length()-1; 
                    if(curr_obj.get_Y()-mypadcol==mcol||curr_obj.get_Y()-mypadcol>mcol){
                          mypadcol = C;
                      }
                   if(curr_obj.get_X()-mypadpos==mrow||curr_obj.get_X()-mypadpos>mrow){
                         mypadpos = R;
                      }
                   if(curr_obj.get_X()<mrow){
                            mypadpos = 0;
                   }
                   if(curr_obj.get_X()>mrow||curr_obj.get_X()==mrow){
                         mypadpos=(curr_obj.get_X()/mrow)*mrow;
                      }
                   if(curr_obj.get_Y()>mcol){
                         mypadcol=(curr_obj.get_Y()/mcol)*mcol;
                      }
                   if(curr_obj.get_Y()<mcol){
                            mypadcol = 0;
                   }
                        break;                                              
                     }                                                                                
     }
     int i=0;
     node *temp = this->head;
               while(temp!=NULL){                                                            
                    i=0;
                   while(temp->get_data()[i]) {
                        wprintw(pad,"%c",temp->get_data()[i]);
                        refresh();
                        i++;
                  }
               temp = temp->get_next_node();     
               }
               wmove(pad,R,C);
               wrefresh(pad);
               prefresh(pad,mypadpos,mypadcol,0,0,mrow-1,mcol-1);
}

//Function Used For Find And Replace.
void ll::find_window(){
          mypadpos=0;
          mypadcol=0;
          int a=0;
          int i,j=0;
          find_string="ENTER THE WORD TO FIND AND REPLACE: ";
          i=find_string.length();
          wprintw(frpad,"%s",find_string.c_str());
          prefresh(frpad,mypadpos,mypadcol,0,0,mrow-1,mcol-1); 
          while(a!=27){
                 delwin(frpad);
                 frpad = newpad(500,500);
                 wprintw(frpad,"%s",find_string.c_str());
                 prefresh(frpad,mypadpos,mypadcol,0,0,mrow-1,mcol-1); 
                 a = getch();
                 if(a!=27&&a!='/'){
                 find_string.insert(find_string.begin()+i,a);  
                 i++;
                 }
                 if(a=='/'&&find_string.length()!=36){
                     //delwin(frpad);
                     //frpad = newpad(500,500);
                     find_string.erase(find_string.length()-1);
                     wprintw(frpad,"%s",find_string.c_str());
                     prefresh(frpad,mypadpos,mypadcol,0,0,mrow-1,mcol-1);
                     i--;   
                 }
                 }
                 //wprintw(frpad,"%s",find_string.c_str());
                 wclear(frpad);
                 wrefresh(frpad);
                 prefresh(frpad,mypadpos,mypadcol,0,0,mrow-1,mcol-1);
                 find_string.erase(find_string.begin(),find_string.begin()+36);
                
}

/*//Funcion for the menu of find and replace. 
void ll::find_window1(){
          int c=0,i=0;
          int menux=mrow-3+1;
      int menuy=3;
          find_string="ENTER THE WORD TO FIND: ";
          i = find_string.length();
          while(c != 27){
          noecho();
          c = getch();
          //wclear(find_replace_menu);
          find_replace_menu = create_win(3, mcol-1,mrow-3,0);
          find_string.insert(find_string.begin()+i,c);
          mvprintw(LINES-2,mcol-7, "FIND"); 
      attron(A_REVERSE);
             init_pair(1, COLOR_WHITE, COLOR_BLACK);
            attron(COLOR_PAIR(1));
          if(i<mcol-9);
          mvprintw(LINES-2, 1,"%s",find_string.c_str());
          //clrtoeol();
      attroff(COLOR_PAIR(1));
          attroff(A_REVERSE);
          i++;
          }
          find_string.erase(find_string.begin(),find_string.begin()+25);
          find_string.erase(find_string.end()-1);
}*/


void ll::find_window1(){
        mypadpos=0;
        mypadcol=0;
        menu1=create_win(4,mcol,mrow-4,0);
    
             int row,col;
    row=1;
    col=mcol-7;
    int c;
    int i=7;
    int i1=0,i2=0;
    mvwprintw(menu1, 1,2, "ENTER TEXT:");
        //mvwprintw(menu1,2.5,2, "REPLACE WITH:");
        mvwprintw(menu1,1,mcol-7,"FIND");
        mvwprintw(menu1,2.5,2,"ENTER TEXT:");
        mvwprintw(menu1,2.5,mcol-20,"REPLACE");
        mvwprintw(menu1,2.5,mcol-12,"REPLACE ALL");
        wmove(menu1,row,col);
            wrefresh(menu1);
        while(1)
        {
                        //keypad(menu1,TRUE);
            wmove(menu1,row,col);
            wrefresh(menu1);
            noecho();
            c=getch();
                        if(c==','){
                           if(find_stack.empty()!=1) 
                           vector<stack_obj>().swap(find_stack);
                           replace_stack.clear();
                           delwin(menu1);
                           break;
                        }
                        //if(c==27)
                        //{delwin(menu1);
                         //break;
                        //}
            if(c=='\033')
            {
                noecho();
                getch();
                noecho();
                c=getch();
                if(c=='A')
                {
                    if(row==1)
                    {
                    row=2.5;
                    col=mcol-20;
                    }
                    else
                    {
                        row=1;
                        col=mcol-7;
                    }
                }
                else if(c=='B')
                {
                    if(row==1)
                    {
                    row=2.5;
                    col=mcol-20;
                    }
                    else
                    {
                        row=1;
                        col=mcol-7;
                    }
                }
                else if(c=='C')
                {
                    if(row==1)
                    {
                        if(i1<find_string.length())
                        {
                            i1++;
                        }
                    }
                    else
                    {
                        if(i2<replace_string.length())
                        i2++;
                    }
                }
                else if(c=='D')
                {
                    if(row==1)
                    {
                        if(i1!=0)
                        {
                            i1--;
                        }
                        
                    }
                    else
                    {
                        if(i2!=0)
                        i2--;
                        
                    }
                }
            }
            else if(c==10)
            {
                if(row==1)
                {       
                         this->find_string_in_text();
                                        //noecho();
                                        //int a = getch();
                                        this->movement_find();
                                        this->print_link_list();
                                        //if(c=getch()==27){
                                        //delwin(menu1);
                                        //print_link_list();
                                        //}
                                        
                }
                else if(row==2)
                {     
                    if(col == mcol-12){ 
                                        //delwin(pad);
                                        //pad = newpad(500,500);
                                        //this->replace();
                                        this->replace_word_in_text();
                                        R=0;
                                        C=0;
                                        pad = newpad(500,500);
                                        this->print_link_list();
                                        //delwin(menu1);
                                        //this->print_link_list();
                                        vector<stack_obj>().swap(find_stack);
                                        replace_stack.clear();
                                        delwin(menu1);
                                        break;
                                        }
                                        else if(col == mcol-20){
                                              //delwin(pad);
                                              //pad = newpad(500,500); 
                                              this->replace_a_word_in_text();
                                              R=0;
                                              C=0;
                                              pad = newpad(500,500);
                                              //this->print_link_list();
                                              //delwin(menu1);
                                              this->print_link_list();
                                                vector<stack_obj>().swap(find_stack);
                                              replace_stack.clear();
                                              delwin(menu1);
                                              break;       
                                        }
                }
            }
            else if(c==127)
            {
                if(i1!=0&&row==1)
                {
                        find_string.erase(find_string.begin()+i1-1);
                        i1--;    
                }
                else if(i2!=0&&row!=1)
                {
                    replace_string.erase(replace_string.begin()+i2-1);
                        i2--;    
                }
            }
            else if(c==9)
            {
                if(col==mcol-20)
                col=mcol-12;
                else if(col==mcol-12)
                col=mcol-20;
            }
            else
            {
                if(row==1)
                {
                    find_string.insert(i1,1,(char)c);
                    i1++;
                }
                else
                {       
                    replace_string.insert(i2,1,(char)c);
                    i2++;
                }
                
            }
            int l=13;
            delwin(menu1);
            menu1=create_win(4,mcol,mrow-4,0);
            mvwprintw(menu1, 1,2, "ENTER TEXT:");
        //mvwprintw(menu1,2.5,2, "REPLACE WITH:");
        mvwprintw(menu1,1,mcol-7,"FIND");
        mvwprintw(menu1,2.5,2,"ENTER TEXT:");
        mvwprintw(menu1,2.5,mcol-20,"REPLACE");
        mvwprintw(menu1,2.5,mcol-12,"REPLACE ALL");
            for(int k=0;l<mcol-7;k++)
            {
                if(find_string[k]=='\0')
                break;
                mvwprintw(menu1,1,l++,"%c",find_string[k]);
            }
             l=13;
            for(int k=0;l<mcol-20;k++)
            {
                if(replace_string[k]=='\0')
                break;
                mvwprintw(menu1,2.5,l++,"%c",replace_string[k]);
            }    
        }
}

/*void ll::find_window2(){
          int c=0,i=0;
          int menux=mrow-3+1;
      int menuy=3;
          man_string="ENTER THE WORD TO FIND AND REPLACE: ";
          man_string = man_string + find_string;
          i = man_string.length();
          while(c != 27){
          c = getch();
          find_replace_menu = create_win(3, mcol-1,mrow-3,0);
          if(c!='\033')
          man_string.insert(man_string.begin()+i,c); 
      attron(A_REVERSE);
             init_pair(1, COLOR_WHITE, COLOR_BLACK);
            attron(COLOR_PAIR(1));
          mvprintw(LINES-2, 1,"%s",man_string.c_str());
          //clrtoeol();
      attroff(COLOR_PAIR(1));
          attroff(A_REVERSE);
          i++;
          }
          man_string.erase(man_string.begin(),man_string.begin()+36);
          man_string.erase(man_string.end()-1);
}*/

//To find the string in text.
void ll::find_string_in_text(){
       mypadpos=0;
       mypadcol=0;
       node *temp = this->get_head();
       string row;
       stack_obj obj;
       int a,found,Row=0;
       while(temp != NULL){
            row = temp->get_data();
            found=row.find(find_string);
            //wprintw(pad,"%s",find_string.c_str());
            //prefresh(frpad,mypadpos,mypadcol,0,0,mrow-1,mcol-1);
            while(found!=string::npos&&found!=row.length()){  
                        prefresh(frpad,mypadpos,mypadcol,0,0,mrow-1,mcol-1);         
                        obj.set_Y(found);
                        obj.set_X(Row);
                        find_stack.push_back(obj);
                        found = row.find(find_string,found+1);
                 }
         Row++;
         temp=temp->get_next_node();
       }
}

//To colour the text which is found.
/*void ll::colour_text(){
      int i=0;
      init_pair(1,COLOR_RED,COLOR_BLACK);
      stack_obj obj;
      if(find_stack.empty()!=1)
      obj = find_stack[0];
      while(i<find_stack.size()){
      R = obj.get_X();
      node *curr_node = mp[R];
      C = obj.get_Y();     
      //mvchgat(obj.get_X(),obj.get_Y(),find_string.length(),A_BLINK,1,NULL);
      attron(COLOR_PAIR(1));
      wprintw(pad,"%s",curr_node->get_data().c_str());
      prefresh(pad,mypadpos,mypadcol,0,0,mrow-1,mcol-1);
      find_stack.pop();
      i++;
}*/

void ll::movement_find(){
     mypadpos=0;
     mypadcol=0;
     int a=0;
     stack_obj obj;
     while(a!=']'){
            /*noecho();
            a=wgetch(pad);
            if(a==']'){
               //find_stack.clear();
               //delwin(pad);
               //if(find_string.empty()!=1)
               //find_string.erase(find_string.begin(),find_string.end());
               wclear(pad);
               wrefresh(pad); 
               break;
            }*/        
            //wclear(pad);
            //wrefresh(pad);
            //delwin(pad);
            //pad = newpad(500,500);        
            int i=0;
            while(i<find_stack.size()){
                     obj = find_stack[i];
                     R = obj.get_X();
                     C = obj.get_Y();
                     PREVROW = R;
                     PREVCOL = C;
                     mypadpos = R;
                     mypadcol =0;
                     if(obj.get_Y()-mypadcol==mcol||obj.get_Y()-mypadcol>mcol){
                          mypadcol = C-find_string.length();
                     } 
                     wclear(pad);
                     wrefresh(pad); 
                     i++;
                     this->print_link_list();
                     noecho();
                     a=wgetch(pad);
                     //pad = newpad(500,500);
                     //this->print_link_list();
                     if(a==']'){
                        //find_stack.clear();
                        //delwin(pad);
                        /*if(find_string.empty()!=1)
                        find_string.erase(find_string.begin(),find_string.end());*/
                        wclear(pad);
                        wrefresh(pad); 
                        break;
                     }
                     delwin(pad);
                     pad = newpad(500,500);
                     //this->find_window1();
                     //noecho();
                     //pad = newpad(500,500);
                     //this->print_link_list();
            }
          if(a==']'){
               replace_stack = find_stack;
               vector<stack_obj>().swap(find_stack);
               //find_string.erase(find_string.begin(),find_string.end());
               break;
          }            
     }
     //delwin(find_replace_menu);
}


//To replace the word.
/*void ll::replace(){
      mypadpos=0;
      mypadcol=0; 
      int i,a=0;
      //replace_string = "Enter the string to replace the old word: ";
      //i=replace_string.length();
          wprintw(frpad,"%s",replace_string.c_str());
          prefresh(frpad,mypadpos,mypadcol,0,0,mrow-1,mcol-1); 
          while(a!=27){
                 delwin(frpad);
                 frpad = newpad(500,500);
                 wprintw(frpad,"%s",replace_string.c_str());
                 prefresh(frpad,mypadpos,mypadcol,0,0,mrow-1,mcol-1); 
                 a = getch();
                 if(a!=27&&a!='/'){
                 replace_string.insert(replace_string.begin()+i,a);  
                 i++;
                 }
                 if(a=='/'&&replace_string.length()!=42){
                     //delwin(frpad);
                     //frpad = newpad(500,500);
                     replace_string.erase(replace_string.length()-1);
                     wprintw(frpad,"%s",replace_string.c_str());
                     prefresh(frpad,mypadpos,mypadcol,0,0,mrow-1,mcol-1);
                     i--;   
                 }
                 }
                 wprintw(frpad,"%s",find_string.c_str());
                 wclear(frpad);
                 wrefresh(frpad);
                 prefresh(frpad,mypadpos,mypadcol,0,0,mrow-1,mcol-1);
                 replace_string.erase(replace_string.begin(),replace_string.begin()+42);
}*/


//To replace the word in whole text.
void ll::replace_word_in_text(){
     mypadpos=0;
     mypadcol=0;
     stack_obj obj;
     string temp_data;
     int i=0;
     while(i<replace_stack.size()){
          obj = replace_stack[i];
          R = obj.get_X();
          C = obj.get_Y();
          temp_data = mp[R]->get_data();
          temp_data.replace(C,find_string.length(),replace_string);
          mp[R]->set_data(temp_data);
          i++;
     }            
       replace_string.erase(replace_string.begin(),replace_string.end());
       replace_stack.clear();
}

//To replace a specific word.
void ll::replace_a_word_in_text(){
     mypadpos=0;
     mypadcol=0;
     stack_obj obj;
     string temp_data;
     int i=0;
     //while(i<replace_stack.size()){
          //obj = find_stack[i];
          //if(obj.get_X() ==PREVROW &&obj.get_Y() ==PREVCOL){
          //R = obj.get_X();
          //C = obj.get_Y();
          temp_data = mp[R]->get_data();
          temp_data.replace(C,find_string.length(),replace_string);
          mp[R]->set_data(temp_data);
          //PREVROW=0;
          //PREVCOL=0;
          //}
          //i++;
     //}
     replace_string.erase(replace_string.begin(),replace_string.end());
     replace_stack.clear();            
}


//To create a menu for saving and other stuff.
void ll::create_menu(char *file_name){
                int c;
        int menux=mrow/4-3;
        int menuy=mcol/4-3;
        menu = create_win(mrow/2, mcol/2,mrow/4,mcol/4);
        mvwprintw(menu, mrow/4-3,mcol/4-3, "SAVE FILE");
        mvwprintw(menu, mrow/4-2,mcol/4-3, "CANCEL");
        mvwprintw(menu, mrow/4-1,mcol/4-3, "EXIT");
        wmove(menu,menux,menuy);
            
    while(1)
    {
        wrefresh(menu);
        noecho();
        c=wgetch(menu);
        if(c=='\033')
        {
            getch();
            c=getch();
            if(c=='A')
            {
                if(menux==mrow/4-3)
                {
                    menux=mrow/4-1;
                }
                else if(menux==mrow/4-1)
                {
                    menux=mrow/4-2;
                }
                else
                menux=mrow/4-3;
            }
        else if(c=='B')
        {
            if(menux==mrow/4-3)
            {
                menux=mrow/4-2;
            }
            else if(menux==mrow/4-1)
            {
                menux=mrow/4-3;
            }
            else
            menux=mrow/4-1;
        }
        }
        else if(c==10)
        break;
        else if(c==10)
        break;
        menu = create_win(mrow/2, mcol/2,mrow/4,mcol/4);
        mvwprintw(menu, mrow/4-3,mcol/4-3, "SAVE FILE");
        mvwprintw(menu, mrow/4-2,mcol/4-3, "CANCEL");
        mvwprintw(menu, mrow/4-1,mcol/4-3, "EXIT");
        wmove(menu,menux,menuy);
    }
    if(menux==mrow/4-3)
    {    
         node*head = this->head;
         ofstream myfile(file_name);
         while(head!=NULL){
              string data = head->get_data();
              //data.erase(data.length()-1);
              myfile<<data;  
              head = head->get_next_node();
         } 
         myfile.close();
    }
    else if(menux==mrow/4-2){
        endwin();
    return;
        }
    else{
        endwin();
    exit(1);
        }
}


//Function to read the file.
string read_file(char *file_name){
    char *data;
    string dat;                                                
    data = new char[1000];
    ifstream myfile(file_name);                                                
    if(myfile.is_open())
    {   
        while(!myfile.eof()){
        string dat1;
        getline(myfile,dat1);
        if(dat1=="")
        dat1 = '\n';
        dat = dat + dat1;
        if(dat[dat.length()-1]!='\n'){
        dat = dat + '\n';
        }
        }
        myfile.close();
    }
    else{
        cout<<"Unable To Open The File";
    } 
    return dat;
}


//Function to save the file.
void ll::save_file(char *file_name){
         node*head = this->head;
         ofstream myfile(file_name);
         while(head!=NULL){
              string data = head->get_data();
              //data.erase(data.length()-1);
              myfile<<data;  
              head = head->get_next_node();
         } 
         myfile.close();
}

//to print the vector which contains the row address.
void node::print_vector(){
    int i=0;
    for(i=0;i<mp.size();i++){
                     cout<<mp[i]->get_data(); 
          }
          cout<<mp.size();             
}

//print the linklist for data checking.
void ll::print(){
         node* temp = this->head;
         while(temp!=NULL){
              cout<<temp->get_data();
              temp = temp->get_next_node();
         }
}




int main(int argc,char *argv[]){
        ll A;
        string prev_data; 
        int i=0,a;     
        initscr();
        start_color();
        refresh();
        mousemask(ALL_MOUSE_EVENTS | REPORT_MOUSE_POSITION ,NULL);
        getmaxyx(stdscr, mrow, mcol);
        //keypad(stdscr, TRUE);
        //printw("%d %d",mrow,mcol);
        pad = newpad(500,500);
        if(has_colors() == FALSE){
              endwin();
              cout<<"Your terminal does not support colour.\n";
              exit(1);
        }
        if(argc == 2){
                if(strcmp(argv[1],"texted.txt")==0){
                      prev_data=read_file(argv[1]); 
                      //cout<<prev_data;
                      /*for(i=0;i<prev_data.length();i++)
                         {   
                                 if(prev_data[i]=='\n'){
                                      cout<<i<<" ";
                                  }
                         }*/
                      A.adress_tracking(prev_data);
                      A.print_link_list();
                      //A.print();
                      while(1){ 
                          delwin(pad);
                          pad = newpad(500,500);
                              noecho();
                              a=getch();
                              if(a=='\033')       //Condition For checking arrow Button Press.
                                   A.move_cursor_arrow();
                              else if(a == '\n')
                                   A.Enter_key_pressed();
                              else if(a == 127)
                                   A.Backspace_key_pressed();
                              else if(a == '~')
                                   A.Delete_key_pressed();
                              else if((a>='a'&&a<='z')||(a>='A'&&a<='Z')||a==' ')
                                   A.Write_into_text(a);
                              else if(a == '/'&&undo_stack.empty()!=1)
                                   A.undo();
                              else if(a == ';'&&redo_stack.empty()!=1)
                                   A.redo();
                              else if(a == '['){
                                    if(find_stack.empty()!=1)
                                          vector<stack_obj>().swap(find_stack);
                                   if(find_string.empty()!=1)
                                        find_string.erase(find_string.begin(),find_string.end());
                                    A.find_window1(); 
                                    //prefresh(frpad,mypadpos,mypadcol,0,0,mrow-1,mcol-1);   
                                    //A.find_window();
                                    //delwin(frpad);
                                    //delwin(find_replace_menu);
                                    //pad = newpad(500,500);
                                    //wprintw(pad,"%s",find_string.c_str());
                                    //prefresh(pad,mypadpos,mypadcol,0,0,mrow-1,mcol-1);
                                    //A.print_link_list();
                                    //A.find_string_in_text();
                                    //A.colour_text();
                                    //A.movement_find();
                                    //delwin(menu1);
                                    //A.print_link_list();
                              }
                              else if(a=='-'){
                                      A.find_window1();
                                      //delwin(pad);
                                      //frpad = newpad(500,500);
                                      //prefresh(pad,mypadpos,mypadcol,0,0,mrow-1,mcol-1);
                                      //A.replace();
                                      //delwin(frpad);
                                      //A.replace_word_in_text();
                                      //pad = newpad(500,500);
                                      //A.print_link_list();       
                              }
                              else if(a == '`'){ 
                                    A.create_menu(argv[1]);
                                    pad = newpad(500,500);
                                    A.print_link_list();
                                    //A.save_file(argv[1]);
                              }
                              /*else if(a==KEY_MOUSE){
                                   MEVENT *event;
                                   if(getmouse(event)){
                                       wclear(pad);
                                       wrefresh(pad);
                                       node *temp = A.get_head();
               while(temp!=NULL){                                                            
                    i=0;
                   while(temp->get_data()[i]) {
                        wprintw(pad,"%c",temp->get_data()[i]);
                        refresh();
                        i++;
                  }
               temp = temp->get_next_node();     
               }
               wmove(pad,event->x/1,event->y/1);
               wrefresh(pad);
               prefresh(pad,mypadpos,mypadcol,0,0,mrow-1,mcol-1);   
                                       
                                   }  
                              }*/
                                    
                              //else if()
                              //printw("%d",mp.size());
                              //clear();
                              //refresh();
                      }
                      //node::print_vector();                     
                 }
        }
        endwin();
        delwin(pad);
        
}
